rule Goal {
    ExprP0,
}

rule ParamList {
    "(" ")" { (_1, _2) => mk_node(A.param_list, args: ()) },
}

rule ExprP8 {
    ident, int, float, string, bool, none,
    "(" Expr ")" { (_1, e, _2) => mk_node(A.paren, expr: e) },
}

rule ExprP7 {
    ExprP8,
    "+" ExprP8 { (_, e) => mk_node(A.unary_plus, arg: e) },
    "-" ExprP8 { (_, e) => mk_node(A.unary_minus, arg: e) },
    ExprP8 "." ident { (l, _, r) => mk_node(A.member_access, lhs: l, rhs: r) },
    ExprP8 ParamList { (f, args) => mk_node(A.call, func: f, args: args) },
}

rule ExprP6 {
    ExprP7,
    ExprP6 "*" ExprP7 { (l, _, r) => mk_node(A.binary_mul, lhs: l, rhs: r) },
    ExprP6 "/" ExprP7 { (l, _, r) => mk_node(A.binary_div, lhs: l, rhs: r) },
}

rule ExprP5 {
    ExprP6,
    ExprP5 "+" ExprP6 { (l, _, r) => mk_node(A.binary_add, lhs: l, rhs: r) },
    ExprP5 "-" ExprP6 { (l, _, r) => mk_node(A.binary_sub, lhs: l, rhs: r) },
}

rule ExprP4 {
    ExprP5,
    ExprP4 "==" ExprP5 { (l, _, r) => mk_node(A.binary_eq, lhs: l, rhs: r) },
    ExprP4 "!=" ExprP5 { (l, _, r) => mk_node(A.binary_ne, lhs: l, rhs: r) },
    ExprP4 "<" ExprP5 { (l, _, r) => mk_node(A.binary_lt, lhs: l, rhs: r) },
    ExprP4 ">" ExprP5 { (l, _, r) => mk_node(A.binary_gt, lhs: l, rhs: r) },
    ExprP4 "<=" ExprP5 { (l, _, r) => mk_node(A.binary_le, lhs: l, rhs: r) },
    ExprP4 ">=" ExprP5 { (l, _, r) => mk_node(A.binary_ge, lhs: l, rhs: r) },
    ExprP4 in ExprP5 { (l, _, r) => mk_node(A.binary_in, lhs: l, rhs: r) },
    ExprP4 not in ExprP5 { (l, _1, _2, r) => mk_node(A.binary_not_in, lhs: l, rhs: r) },
}

rule ExprP3 {
    ExprP4,
    not ExprP4 { (_, e) => mk_node(A.unary_not, arg: e) },
    ExprP3 and ExprP4 { (l, _, r) => mk_node(A.binary_and, lhs: l, rhs: r) },
}

rule ExprP2 {
    ExprP3,
    ExprP2 or ExprP3 { (l, _, r) => mk_node(A.binary_or, lhs: l, rhs: r) },
}

rule ExprP1 {
    ExprP2,
    ExprP8 "=" ExprP2 { (l, _, r) => mk_node(A.assign, lhs: l, rhs: r) },
    ExprP8 "+=" ExprP2 { (l, _, r) => mk_node(A.add_assign, lhs: l, rhs: r) },
    ExprP8 "-=" ExprP2 { (l, _, r) => mk_node(A.sub_assign, lhs: l, rhs: r) },
    ExprP8 "*=" ExprP2 { (l, _, r) => mk_node(A.mul_assign, lhs: l, rhs: r) },
    ExprP8 "/=" ExprP2 { (l, _, r) => mk_node(A.div_assign, lhs: l, rhs: r) },
}

rule Expr {
    ExprP1,
}

rule eps {
    EPS { () => none },
}

cast ident(T.ident) {
    x => mk_node(A.ident, name: x.text)
}

cast int(T.literal_int) {
    x => mk_node(A.literal_int, value: x.text)
}

cast float(T.literal_float) {
    x => mk_node(A.literal_float, value: x.text)
}

cast string(T.literal_string) {
    x => mk_node(A.literal_string, value: x.text)
}

cast bool(T.literal_bool) {
    x => mk_node(A.literal_bool, value: x.text)
}

cast none(T.literal_none);

cast let(T.kw_let);
cast set(T.kw_set);
cast show(T.kw_show);
cast if(T.kw_if);
cast else(T.kw_else);
cast for(T.kw_for);
cast while(T.kw_while);
cast break(T.kw_break);
cast continue(T.kw_continue);
cast include(T.kw_include);
cast import(T.kw_import);
cast from(T.kw_from);
cast in(T.kw_in);
cast not(T.kw_not);
cast and(T.kw_and);
cast or(T.kw_or);

cast "+"(T.punc_plus);
cast "-"(T.punc_minus);
cast "*"(T.punc_star);
cast "/"(T.punc_slash);
cast "."(T.punc_dot);
cast ".."(T.punc_dotdot);
cast "="(T.punc_eq);
cast "+="(T.punc_pluseq);
cast "-="(T.punc_minuseq);
cast "*="(T.punc_stareq);
cast "/="(T.punc_slasheq);
cast "=="(T.punc_eqeq);
cast "!="(T.punc_neq);
cast "<"(T.punc_lt);
cast ">"(T.punc_gt);
cast "<="(T.punc_le);
cast ">="(T.punc_ge);
cast "("(T.punc_lparen);
cast ")"(T.punc_rparen);
cast "["(T.punc_lbracket);
cast "]"(T.punc_rbracket);
cast "{"(T.punc_lbrace);
cast "}"(T.punc_rbrace);
cast "#"(T.punc_hash);
cast ","(T.punc_comma);
cast ":"(T.punc_colon);
cast "=>"(T.punc_arrow);
cast ";"(T.punc_semi);
cast "$"(T.punc_dollar);

cast hs(T.hspace);
cast vs(T.vspace);

cast comment_doc(T.comment_doc) {
    x => mk_node(A.comment_doc, value: x.text)
}

cast comment_doc_outer(T.comment_doc_outer) {
    x => mk_node(A.comment_doc_outer, value: x.text)
}

cast comment_(T.comment_);
cast comment_block(T.comment_block);

cast unknown(T.unknown) {
    x => mk_node(A.unknown, value: x.text)
}
